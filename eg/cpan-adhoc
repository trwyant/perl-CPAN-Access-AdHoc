#!/usr/bin/env perl

use 5.010;

use strict;
use warnings;

use autodie;

use Config;
use CPAN::DistnameInfo;
use CPAN::Access::AdHoc;
use CPAN::Access::AdHoc::Util qw{
    __expand_distribution_path
    HASH_REF
};
use Cwd;
use File::Temp;
use Getopt::Long 2.33 qw{ :config auto_version };
use List::Util qw{ any };
use Pod::Usage;
use POSIX qw{ strftime };
use Term::ReadLine;
use Text::ParseWords qw{ shellwords };
use version 0.77;
use YAML::Any;

our $VERSION = '0.000_233';

use constant CURRENT_PACKAGE => 'current';

my %opt = (
    date_format	=> '%d-%b-%Y %H:%M:%S',
    verbose	=> -t STDIN,
);

GetOptions( \%opt,
    qw{
	date_format|date-format=s debug!
	undef_if_not_found|undef-if-not-found! verbose!
    },
    'help|?' => sub { pod2usage( { -verbose => 2 } ) },
) or pod2usage( { -verbose => 0 } );

my $rl;
{
    my $banner = <<"EOD";

cpan-adhoc - Get arbitrary information from a CPAN mirror.
Version $VERSION, based on CPAN::Access::AdHoc version @{[
    CPAN::Access::AdHoc->VERSION ]}

Use 'help' for documentation, copyright, and license.

EOD

    if ( -t STDIN ) {
	my $trl = Term::ReadLine->new( 'cpan-adhoc' );
	$rl = sub {
	    return $trl->readline( $_[0] );
	};
	warn $banner;
    } elsif ( -t STDOUT && $opt{verbose} ) {
	$rl = sub { print @_; return scalar <STDIN> };
	warn $banner;
    } else {
	$rl = sub { return scalar <STDIN> };
    }
}

my $cad = CPAN::Access::AdHoc->new(
    __debug		=> $opt{debug},
    undef_if_not_found	=> $opt{undef_if_not_found},
);
my %dist;

@ARGV
    and verb_cpan( shift @ARGV );

MAIN_LOOP:
while ( defined( my $buffer = $rl->( 'cpan-adhoc> ' ) ) ) {
    $buffer =~ s/ \s+ \z //smx;
    $buffer =~ s/ \A \s+ //smx;
    '' eq $buffer
	and next;
    $buffer =~ m/ \A [#] /smx
	and next;
    my ( $verb, @args ) = shellwords( $buffer );
    if ( my $code = __PACKAGE__->can( "verb_$verb" ) ) {
	eval {
	    $code->( @args );
	    1;
	} or warn $@;
    } else {
	warn "Unrecognized verb '$verb'\n";
    }
}

{
    no warnings qw{ once };
    -t STDOUT
	and say '';
}

sub verb_alias {
    my ( $old, $new ) = @_;
    defined $old
	or die "Package alias must be given\n";
    defined $new
	or ( $old, $new ) = ( CURRENT_PACKAGE, $old );
    $dist{$new} = _resolve_unique_distribution( $old, record => 1 );
    return;
}

sub verb_author {
    my @ids = @_;

    my $author_index = $cad->fetch_author_index();
    @ids
	or @ids = sort keys %{ $author_index };

    foreach my $id ( @ids ) {
	$id = uc $id;
	if ( my $auth = $author_index->{$id} ) {
	    say join "\t", $id, $auth->{name}, $auth->{address};
	} else {
	    warn "Author $id not found\n";
	}
    }

    return;
}

sub verb_base {
    my @argv = @_;
    @argv or @argv = ( CURRENT_PACKAGE );
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution( $name,
	    record	=> 1,
	    warn	=> 1,
	) or next;
	my $di = $pkg->{info};
	say sprintf '%s/%s  %s', $di->cpanid(), $di->filename(),
	    _get_archive( $pkg )->base_directory();
    }
    return;
}

sub verb_cache {
    foreach my $pkg ( sort keys %dist ) {
	say join "\t", $pkg, $dist{$pkg}{name};
    }
    return;
}

sub verb_cd {
    my ( $dir ) = @_;
    if ( defined $dir ) {
	chdir $dir
	    or die "Failed to cd to $dir: $!\n";
    } else {
	chdir
	    or die "Failed to cd to home directory: $!\n";
    }
    return;
}

sub verb_checksums {
    my ( $author ) = @_;
    defined $author
	or die 'Must specify a CPAN ID';
    my $cksum = $cad->fetch_distribution_checksums( $author );
    say $author;
    print Dump( $cksum );
    return;
}

sub verb_choose {
    my @argv = @_;
    @argv == 1
	or die "The choose command takes exactly one argument.\n";
    $dist{$argv[0]}
	or die _err_not_requested( $argv[0] );
    $dist{+CURRENT_PACKAGE} = $dist{$argv[0]};
    return;
}

sub verb_clean_checksums {
    my ( $arg ) = @_;
    if ( @_ ) {
	$cad->clean_checksums( $arg );
    } else {
	say $cad->clean_checksums() ? 1 : 0;
    }
    return;
}

sub verb_clear {
    %dist = ();
    $cad->flush();
    return;
}

sub verb_copy {
    my ( $pkg, $file ) = _validate_pkg_file( @_ );
    my $content = _get_archive( $pkg )->get_item_content( $file );
    state $unused = do {
	require Clipboard;
	Clipboard->import();
    };
    Clipboard->copy( $content );
    return;
}

sub verb_corpus {
    my @argv = @_;
    my %opt = (
	format	=> '%Y-%m-%d',
    );
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ before=s
	development! date|by_date|by-date! distribution|distro!
	format=s latest! match=s
	production! quiet! requires=s
	since=s unreleased|unpublished!
	with=s@ without=s@
	} )
	or return;
    @argv
	or @argv = ( $cad->pause_user() );
    @argv
	or die "No author specified\n";
    _default_boolean_option_group(
	\%opt, qw{ development production unreleased } );
    foreach my $name ( qw{ before since } ) {
	$opt{$name}
	    or next;
	$opt{$name} = _parse_date( $opt{$name} );
    }
    $opt{hash} = 1;
    my $inx = $cad->fetch_author_index();
    my $fmtr = $opt{distribution} ? sub {
	my ( $item ) = @_;
	return $item->{info}->dist();
    } : sub {
	my ( $item ) = @_;
	return (
	    '    ',
	    $item->{info}->filename(), "\t", strftime(
		$opt{format}, localtime $item->{mtime} )
	);
    };
    defined $opt{match}
	and $opt{match} = qr/$opt{match}/;
    foreach my $id ( @argv ) {
	my $uc_id = uc $id;
	if ( $inx->{$uc_id} ) {
	    my @found = $cad->corpus( $uc_id, %opt );
	    $opt{quiet}
		and not @found
		and next;
	    1 == @argv
		and $opt{distribution}
		or say sprintf '%-14s %s', $uc_id, $inx->{$uc_id}{address};
	    FOUND:
	    foreach my $item ( @found ) {
		if ( $opt{with} || $opt{without} ) {
		    my $archive = $cad->fetch_distribution_archive(
			$item->{path} );
		    foreach my $path ( @{ $opt{with} || [] } ) {
			$archive->item_present( $path )
			    or next FOUND;
		    }
		    foreach my $path ( @{ $opt{without} || [] } ) {
			$archive->item_present( $path )
			    and next FOUND;
		    }
		}
		say $fmtr->( $item );
	    }
	} else {
	    warn "CPAN ID $uc_id not found\n";
	}
    }
    return;
}

sub verb_cpan {
    my @arg = _expand_default( @_ );
    if ( @arg ) {
	$cad->cpan( @arg );
	verb_clear();
    }
    defined $arg[0]
	or say $cad->cpan();
    return;
}

sub verb_default_cpan_source {
    my @arg = _expand_default( @_ );
    @arg
	and $cad->default_cpan_source( @arg );
    if ( ! defined $arg[0] ) {
	my @src = @{ $cad->default_cpan_source() };
	foreach ( @src ) {
	    s/ \A CPAN::Access::AdHoc::Default::CPAN:: //smx;
	}
	say join ',', @src;
    }
    return;
}

sub verb_undef_if_not_found {
    my @arg = _expand_default( @_ );
    if ( @arg ) {
	$cad->undef_if_not_found( @arg );
    }
    defined $arg[0]
	or say $cad->undef_if_not_found();
    return;
}

sub verb_diff {
    my @argv = @_;
    my ( @d_opt, @d_arg );
    my %opt;
    my $go = Getopt::Long::Parser->new(
	config => [ qw{ pass_through no_auto_abbrev } ] );
    $go->getoptionsfromarray( \@argv, \%opt, qw{ less! } )
	or return;
    while ( @argv ) {
	local $_ = shift @argv;
	if ( '--' eq $_ ) {
	    @d_arg = @argv;
	    last;
	} elsif ( m/ \A - /smx ) {
	    push @d_opt, $_;
	} else {
	    push @d_arg, $_;
	}
    }
    @d_arg
	and @d_arg <= 3
	or die "The diff command requires one to three arguments\n";
    my ( $local, $remote, $pkg ) = reverse @d_arg;
    $remote //= $local;
    my $temp = _fetch_file( $pkg, $remote );
    _issue( \%opt, diff => @d_opt, $temp->filename(), $local );

    return;
}

sub verb_distribution {
    my @argv = @_;
    foreach my $dist ( _resolve_distributions( @argv ) ) {
	_record_distribution( $dist );
	say $dist;
    }
    return;
}

BEGIN {
    no warnings qw{ once };
    *verb_distro = *verb_dist = \&verb_distribution;
}

sub verb_exit {
    no warnings qw{ exiting };
    last MAIN_LOOP;
}

sub verb_extract {
    my ( $name, $target ) = @_;
    defined $name
	and '' ne $name
	or $name = CURRENT_PACKAGE;
    defined $target
	and $target =~ s{ / \z }{}smx;
    my $pkg = _resolve_unique_distribution(
	$name, record => 1, warn => 1 )
	or return;
    my $archive = _get_archive( $pkg );
    $archive->extract( $target );
    my $di = $pkg->{info};
    say sprintf '%s/%s  %s', $di->cpanid(), $di->filename(),
	join '/', grep { defined } $target, $archive->base_directory();
    return;
}

{
    # We pull $temp out of the subroutine like this because we do not
    # want it to go out-of-scope before gvim launches.
    my $temp;

    sub verb_gview {
	my ( $pkg, $file ) = @_;
	$temp = _fetch_file( $pkg, $file );
	_issue( {}, qw{ gvim -R }, $temp->filename() );
	return;
    }
}

sub verb_help {
    pod2usage( { -verbose => 2, -exitval => 'NOEXIT' } );
    return;
}

sub verb_info {
    my @argv = @_;
    @argv or @argv = ( CURRENT_PACKAGE );
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution(
	    $name, record => 1, warn => 1 )
	    or next;
	my $di = $pkg->{info};
	say $di->filename();
	say '    ', $di->cpanid();
    }
    return;
}

sub verb_less {
    my ( $pkg, $file ) = @_;
    my $temp = _fetch_file( $pkg, $file );
    _less( $temp );
    return;
}

sub verb_list {
    my @argv = @_;
    my %opt = (
	format	=> $opt{date_format},
    );
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ l! less! } )
	or return;
    @argv
	or push @argv, CURRENT_PACKAGE;
    my $output = $opt{less} ? File::Temp->new() : *STDOUT;
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution(
	    $name, record => 1, warn => 1 )
	    or next;
	my $archive = _get_archive( $pkg );
	$opt{l}
	    and printf { $output } '%8d  %s  ', $archive->size(),
	    strftime( $opt{format}, localtime $archive->mtime() );
	say { $output } $pkg->{name};
	foreach my $file ( $archive->list_contents() ) {
	    print { $output } '    ';
	    $opt{l}
		and printf { $output } '%8d  %s  ',
		    $archive->get_item_size( $file ),
		    strftime(
			$opt{format},
			localtime $archive->get_item_mtime( $file),
		    );
	    say { $output } $file;
	}
    }
    $opt{less}
	and _less( $output );
    return;
}

sub verb_ls {
    goto &verb_list;
}

sub verb_look {
    my ( $name ) = @_;
    defined $name
	and '' ne $name
	or $name = CURRENT_PACKAGE;
    my $pkg = _resolve_unique_distribution(
	$name,
	record	=> 1,
	warn	=> 0,	# Fatal
    );
    my $dir = File::Temp->newdir();
    my $archive = _get_archive( $pkg );
    $archive->extract( $dir->dirname() );
    my $shell = $ENV{SHELL} // '/bin/sh';
    my $cwd = cwd;
    local $@ = undef;
    eval {
	chdir File::Spec->catdir( $dir->dirname(),
	    $archive->base_directory() );
	system { $shell } $shell;
	1;
    } or warn $@;
    chdir $cwd;
    return;
}

sub verb_metadata {
    my @argv = @_;
    my %opt;
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ less! } )
	or return;
    @argv or push @argv, CURRENT_PACKAGE;
    my $output = $opt{less} ? File::Temp->new() : *STDOUT;
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution(
	    $name, record => 1, warn => 1 )
	    or next;
	my $dv = $pkg->{info}->distvname();
	if ( my $meta = _get_archive( $pkg )->metadata() ) {
	    my $ms = $meta->as_string();
	    chomp $ms;
	    say { $output } "$dv: $ms";
	} else {
	    warn "No metadata found for $dv\n";
	}
    }
    $opt{less}
	and _less( $output );
    return;
}

sub verb_module {
    my @argv = @_;
    my $inx = $cad->fetch_module_index();
    foreach my $module ( @argv ) {
	$inx->{$module}
	    or _flunk( "Module '$module' not indexed" )
	    or next;	# _flunk returns false
	my $dist = $inx->{$module}{distribution};
	say join "\t", $module, $inx->{$module}{version}, $dist;
	_record_distribution( $dist );
    }
    return;
}

sub verb_mtime {
    my @argv = @_;
    my %opt = (
	format	=> $opt{date_format},
    );
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ distribution! format=s } )
	or return;
    my $time;
    if ( $opt{distribution} ) {
	my $archive = _get_archive( $argv[0] );
	$time = $archive->mtime();
    } else {
	my ( $pkg, $file ) = _validate_pkg_file( @argv );
	my $archive = _get_archive( $pkg );
	$time = $archive->get_item_mtime( $file );
    }
    say strftime $opt{format}, localtime $time;
    return;
}

sub verb_perldoc {
    my ( $pkg, $file ) = _validate_pkg_file( @_ );
    my $temp = _fetch_file( $pkg, $file );
    _issue( {}, perldoc => $temp );
    return;
}

{
    my $temp;

    sub verb_ppidump {
	my @argv = @_;
	require PPI::Document;
	require PPI::Dumper;
	my %opt = (
	    class	=> 1,
	    comments	=> 1,
	    content	=> 1,
	    indent	=> 2,
	    whitespace	=> 1,
	);
	my $go = Getopt::Long::Parser->new();
	$go->getoptionsfromarray( \@argv, \%opt, qw{
	    class!
	    comments!
	    content!
	    gview!
	    indent=i
	    locations!
	    memaddr!
	    whitespace!
	    } )
	    or return;
	my ( $pkg, $file ) = @argv;
	my $gview = delete $opt{gview};
	my $contents = _get_file_contents( $pkg, $file );
	my $dumper = PPI::Dumper->new(
	    PPI::Document->new( \$contents ),
	    %opt,
	);
	$temp = File::Temp->new();
	print { $temp } $dumper->string();
	seek $temp, 0, 0;
	if ( $gview ) {
	    _issue( {}, qw{ gvim -R }, $temp->filename() );
	} else {
	    _less( $temp );
	}
	return;
    }
}

sub verb_provides {
    my @argv = @_;
    my %opt;
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ less! } )
	or return;
    @argv
	or push @argv, CURRENT_PACKAGE;
    my $output = $opt{less} ? File::Temp->new() : *STDOUT;
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution(
	    $name, record => 1, warn => 1 )
	    or next;
	say { $output } $pkg->{name};
	my $provides = _get_archive( $pkg )->provides();
	foreach my $module ( sort keys %{ $provides } ) {
	    say { $output } '    ', $module, "\t",
		$provides->{$module}{version};
	}
    }
    $opt{less}
	and _less( $output );
    return;
}

sub verb_pwd {
    say cwd;
    return;
}

sub verb_write {
    my @argv = @_;
    @argv or @argv = ( CURRENT_PACKAGE );
    foreach my $name ( @argv ) {
	my $pkg = _resolve_unique_distribution(
	    $name, record => 1, warn => 1 )
	    or next;
	my $archive = _get_archive( $pkg );
	$archive->write();
	my $di = $pkg->{info};
	say sprintf '%s', $di->filename();
    }
    return;
}

# Default a group of Boolean options.
# The arguments are a hash reference and some option names. Nothing is
# returned. The defaults are applied as follows:
#
# * If any option in the group is asserted, the hash is unmodified,
#   which defaults unspecified options to false.
#
# * If no option in the group is asserted but at least one option in the
#   group is negated, any unspecified options are asserted.
#
# * If no options in the group are specified, all are asserted.
#
sub _default_boolean_option_group {
    my ( $opt, @name ) = @_;
    if ( any { $opt->{$_} } @name ) {
    } elsif ( any { exists $opt->{$_} } @name ) {
	foreach ( @name ) {
	    exists $opt->{$_}
		or $opt->{$_} = 1;
	}
    } else {
	@{ $opt }{ @name } = ( 1 ) x scalar @name;
    }
    return;
}

sub _expand_default {
    my @argv = @_;
    my %opt;
    my $go = Getopt::Long::Parser->new();
    $go->getoptionsfromarray( \@argv, \%opt, qw{ default } )
	or die "The only legal option is -default\n";
    if ( $opt{default} ) {
	@argv
	    and die "You may not specify both -default and an argument\n";
	return ( undef );
    } elsif ( @argv ) {
	@argv == 1
	    or die "You may not specify more than one argument\n";
	return @argv;
    } else {
	return;
    }
}

sub _validate_pkg_file {
    my ( $name, $file ) = @_;
    defined $name
	or defined $file
	or die "File name must be given\n";
    defined $file
	or ( $name, $file ) = ( undef, $name );

    if ( ! defined $name ) {
	my $inx = $cad->fetch_module_index();
	$inx->{$file}
	    and $name = $inx->{$file}{distribution};
    }

    $name //= CURRENT_PACKAGE;

    my $pkg = _resolve_unique_distribution( $name,
	record	=> 1 );
    my $dname = $pkg->{info}->distvname();
    my $arch = _get_archive( $pkg );

    $arch->item_present( $file )
	and return ( $pkg->{name}, $file );

    ( my $mp = $file ) =~ s{ :: }{/}smxg;
    my $re = qr{ / \Q$mp\E [.] pm \z }smx;
    foreach my $try ( $arch->list_contents() ) {
	$try =~ $re
	    or next;
	return ( $pkg->{name}, $try );
    }

    die "File '$file' not in distribution '$dname'\n";
}

sub _err_not_requested {
    my ( $name ) = @_;
    return $name eq CURRENT_PACKAGE ?
	"No current package\n" :
	"Package $name never requested by name\n";
}

sub _fetch_file {
    my ( $pkg, $file ) = _validate_pkg_file( @_ );
    my @temp_args;
    $file =~ m/ ( [.] [^.]+ ) \z /smx
	and push @temp_args, SUFFIX => "$1";
    my $content = _get_archive( $pkg )->get_item_content( $file );
    my $temp = File::Temp->new( @temp_args );
    print { $temp } $content;
    return $temp;
}

sub _get_archive {
    my ( $pkg, %arg ) = @_;
    defined $pkg
	or $pkg = CURRENT_PACKAGE;
    if ( ! ref $pkg ) {
	$pkg = _resolve_unique_distribution( $pkg, %arg, record => 1 );
    }
    return (
	$pkg->{archive} ||= $cad->fetch_distribution_archive(
	    $pkg->{name} )
    );
}

sub _get_file_contents {
    my ( $pkg, $file ) = _validate_pkg_file( @_ );
    return _get_archive( $pkg )->get_item_content( $file );
}

sub _record_distribution {
    my ( $pkg, %arg ) = @_;
    defined $pkg
	or return;
    $dist{$pkg}
	and return ( $dist{+CURRENT_PACKAGE} = $dist{$pkg} );
    my $di = CPAN::DistnameInfo->new( $pkg );
    my $dn = $di->dist();
    my $dv = $di->distvname();
    my $version = version->parse( $di->version() );
    defined( my $pathname = $di->pathname() )
	or return _flunk( "$pkg not found", %arg );
    $pathname =~ m{ \A /authors/id/ }smx
	or substr $pathname, 0, 0, '/authors/id/';
    $cad->exists( $pathname )
	or _flunk ( "$pkg not found", %arg );
    $dist{+CURRENT_PACKAGE} = $dist{$pkg} ||= {
	name	=> $pkg,
	version	=> $version,
	dist	=> $dn,
	info	=> $di,
    };

    # $dv and $dn may not be defined if we are dealimg with, e.g., one
    # of Tom Christiansen's unpackaged .pm files, say
    # T/TO/TOMC/scripts/whenon.dir/LastLog/File.pm.gz
    defined $dv
	and $dist{$dv} = $dist{$pkg};
    not defined $dn
	or $dist{$dn} and $dist{$dn}{version} > $version
	or $dist{$dn} = $dist{$pkg};
    return $dist{$pkg};
}

sub _resolve_distributions {
    my @args = @_;
    my %opt;
    @args
	and HASH_REF eq ref $args[-1]
	and %opt = %{ pop @args };
    my $re = qr< @{[ join ' | ', map { quotemeta } @args ]} >smx;
    my @rslt;
    foreach my $dist ( $cad->indexed_distributions() ) {
	$dist =~ $re
	    or next;
	$opt{record}
	    and $dist = _record_distribution( $dist );
	push @rslt, $dist;
    }
    return @rslt;
}

# Resolve a distribution name to a unique distribution, or throw an
# exception. By default the return is the reolved name. If $arg{record}
# is true, though, the distribution is recorded and a reference to the
# record is returned.

sub _resolve_unique_distribution {
    my ( $name, %arg ) = @_;
    $dist{$name}
	and return $arg{record} ? $dist{$name} : $name;

    $name eq CURRENT_PACKAGE
	and _flunk( 'No current package', %arg );
    my @rslt = _resolve_distributions( $name )
	or _flunk( "Distribution $name not found", %arg );
    if ( @rslt > 1 ) {
	my %base;
	foreach my $d ( @rslt ) {
	    my $di = CPAN::DistnameInfo->new( $d );
	    my $dn = $di->dist();
	    my $dv = version->parse( $di->version() );
	    $base{$dn}
		and $base{$dn}{version} >= $dv
		or $base{$dn} = {
		distro	=> $d,
		version	=> $dv,
	    };
	}
	@rslt = map { $base{$_}{distro} } keys %base;
    }
    @rslt > 1
	and return _flunk( "Distribution $name not unique", %arg );
    $arg{record}
	and return _record_distribution( $rslt[0] );
    return $rslt[0];
}

sub _flunk {
    my ( $msg, %arg ) = @_;
    $arg{quiet}
	and return;
    $msg =~ s/ (?<! \n ) \z /\n/smx;
    $arg{warn}
	or die $msg;
    warn $msg;
    return;
}

sub _issue {
    my ( $opt, $name, @args ) = @_;
    if ( $opt->{less} ) {
	my $pid = open my $pipe, '-|';
	if ( ! defined $pid ) {
	    die "Failed to fork: $!\n";
	} elsif ( $pid ) {
	    # Parent
	    my $temp = File::Temp->new();
	    while ( <$pipe> ) {
		print { $temp } $_;
	    }
	    _less( $temp );
	} else {
	    # Child
	    exec { $name } $name, @args;
	    die "Exec failed: $!\n";
	}
    } else {
	system { $name } $name, @args;
    }
    return;
}

{

    my @pager;

    BEGIN {
	@pager = split qr{ \s+ }smx, $Config{pager};
    }

    sub _less {
	my ( $file ) = @_;
	_issue( {}, @pager, $file );
	return;
    }

}

sub _parse_date {
    my ( $date ) = @_;
    if ( $date =~ m/ \A [0-9]{2,4} (?: [^0-9] [0-9]{1,2} ){2,5} \z /smx ) {
	require Time::Local;
	my @parsed = split qr{ [^0-9] }smx, $date;
	$parsed[0] = _parse_date_adjust_year( $parsed[0] );
	$parsed[1] -= 1;
	@parsed < 6
	    and push @parsed, ( 0 ) x ( 6 - @parsed );
	return Time::Local::timelocal( reverse @parsed );
    } else {
	require Date::Manip;
	defined( my $rslt = Date::Manip::UnixDate( $date, '%s' ) )
	    or die "Date::Manip does not recognize '$date'\n";
	return $rslt;
    }
}

sub _parse_date_adjust_year {
    my ( $year ) = @_;
    $year < 60
	and return $year + 100;
    $year < 100
	and return $year;
    $year >= 1900
	and return $year - 1900;
    die "Invalid year '$year'\n";
}

BEGIN {
    $readline::rl_completion_function = __PACKAGE__ .
    '::_readline_completer_function';
}

use File::Glob qw{ bsd_glob };

sub _readline_completer_function {
    no warnings qw{ once };
    my ( $text, $line, $start ) = @_;
    $start
	or return _readline_complete_command( $text );
    state $dispatch = {
	author	=> 'author',
	copy	=> 'element',
	corpus	=> 'author',
	gview	=> 'element',
	less	=> 'element',
	module	=> 'module',
	mtime	=> 'element',
	perldoc	=> 'element',
	ppidump	=> 'element',
    };
    my ( $verb ) = $line =~ m/ ( \w+ ) /smx;
    if ( $dispatch->{$verb} ) {
	my $code;
	$code = __PACKAGE__->can(
	    "_readline_complete_$dispatch->{$verb}" )
	    and goto &$code;
    }
    my @files = bsd_glob( "$text*" );
    if ( $readline::var_CompleteAddsuffix ) {
	foreach ( @files ) {
	    if (-l $_) {
##		$_ .= '@';
	    } elsif (-d _) {
		$_ .= '/';
		$readline::rl_completer_terminator_character = '';
	    } elsif (-x _) {
##		$_ .= '*';
	    } elsif (-S _ || -p _) {
##		$_ .= '=';
	    }
	}
    }
    return @files;
}

sub _readline_complete_author {
    my ( $text ) = @_;
    my $match = qr{ \A \Q$text\E }smxi;
    my $author_index = $cad->fetch_author_index();
    return grep { $_ =~ $match } sort keys %{ $author_index };
}

sub _readline_complete_command {
    my ( $text ) = @_;
    state $commands = _readline_complete_command_list();
    my $match = qr{ \A \Q$text\E }smx;
    return grep { $_ =~ $match } @{ $commands };
}

sub _readline_complete_command_list {
    no strict qw{ refs };
    my $name_space = __PACKAGE__ . '::';
    my @rslt;
    foreach my $name ( sort keys %$name_space ) {
	__PACKAGE__->can( $name )
	    and $name =~ m/ \A verb_ ( \w+ ) /smx
	    and push @rslt, "$1";
    }
    return \@rslt;
}

sub _readline_complete_element {
    my ( $text ) = @_;
    my $pkg = _resolve_unique_distribution( CURRENT_PACKAGE,
	record	=> 1 );
    my $dname = $pkg->{info}->distvname();
    my $arch = _get_archive( $pkg );

    my @rslt;
    my $match = qr{ \A \Q$text\E }smx;

    foreach my $elem ( $arch->list_contents() ) {
	$elem =~ $match
	    or next;
	push @rslt, $elem;
    }
    return @rslt;
}

sub _readline_complete_module {
    my ( $text ) = @_;
    my $match = qr{ ( \A \Q$text\E [^:]* ) }smx;
    my $module_index = $cad->fetch_module_index();
    my %rslt;
    foreach my $module ( keys %{ $module_index } ) {
	$module =~ $match
	    and $rslt{$1} = 1;
    }
    $readline::rl_completer_terminator_character = '';
    return sort keys %rslt;
##    return grep { $_ =~ $match } sort keys %{ $module_index };
}

# Given a version, return:
# 'production' unless it contains an underscore
# 'unreleased' if it has only zeroes and dots before the underscore
# 'development' otherwise.
sub _version_kind {
    my ( $version ) = @_;
    $version =~ m/ _ /smx
	or return 'production';
    $version =~ m/ \A [0.]+ _ /smx
	and return 'unreleased';
    return 'development';
}

__END__

=head1 TITLE

cpan-adhoc - Get arbitrary information from a CPAN mirror.

=head1 SYNOPSIS

 $ cpan-adhoc
 cpan-adhoc> help
 cpan-adhoc> module LWP::UserAgent
 cpan-adhoc> list
 cpan-adhoc> perldoc lib/LWP/UserAgent.pm
 cpan-adhoc> exit
 
 $ cpan-adhoc http://cpan.pair.com/
 cpan-adhoc> ...
 
 $ cpan-adhoc -help
 $ cpan-adhoc -version

=head1 OPTIONS

=head2 -date-format strftime_format

This option specifies the default date format for date and time output.
This can typically be overridden at the individual commands.

The default is C<-date-format '%d-%b-%Y %H:%M:%S'>.

=head2 -help

This option displays the documentation for this script. The script then
exits.

=head2 -verbose

If asserted, this option causes the banner to be printed and commands
echoed when not reading commands from a terminal.

The default is C<-verbose> if standard in is a terminal, and
C<-noverbose> otherwise.

=head2 -version

This option displays the version of this script. The script then exits.

=head1 DETAILS

This Perl script implements an interactive query of a CPAN mirror. The
default is whatever mirror your CPAN client is set to, as determined by
L<CPAN::Access::AdHoc|CPAN::Access::AdHoc>. You can specify a different
mirror on the command line, or using the L<cpan|/cpan> command.

Tab completion is somewhat supported. You can use it to complete command
names. For the C<'author'> and C<'corpus'> commands, arguments are
completed from the author index. For the C<'module'> command, arguments
are completed from the module index. For the C<'copy'>, C<'gview'>,
C<'less'>, C<'mtime'> and C<'perldoc'> commands, arguments are completed
from the element list of the current distribution. For all other
commands, arguments are completed from the files in the current
directory, whether or not this is appropriate to the command.

The following commands are supported:

=head2 alias

 cpan-adhoc> alias libwww-perl libwww
 cpan-adhoc> alias libwww

This command creates an alias for a distribution in the downloaded
distribution stash. It is simply a convenience to save typing if you
have a long distribution name you will be repeatedly typing. The first
argument is the name of a distribution, and the second is the alias.

The single-argument version creates an alias for the current
distribution, if any.

=head2 author

 cpan-adhoc> author
 cpan-adhoc> author adamk rjbs bingos

This command lists items from the author index
F<authors/01mailrc.txt.gz>. If no names are given the whole index is
listed in ASCIIbetical order.

=head2 base

This command displays the base directories for the named distributions.
If no distribution is specified, the current distribution, if any, is
displayed.

=head2 cache

This command lists the distribution names encountered since the
most-recent C<clear>, or since the script started. Each distribution may
appear under multiple names.

=head2 cd

 cpan-adhoc> cd fu/bar
 cpan-adhoc> cd

This command changes the default directory under which the script runs.
Without an argument, it changes to the user's home directory.

=head2 checksums

 cpan-adhoc> checksums MENUHIN
 cpan-adhoc> checksums MENUHIN/Yehudi-0.01.tar.gz

This command displays the checksums for the given author or
distribution.

=head2 choose

 cpan-adhoc> choose libwww-perl

This command makes the given downloaded distribution the default.

=head2 clear

 cpan-adhoc> clear

This command removes all distributions from the stash, and purges cached
data from the L<CPAN::Access::AdHoc|CPAN::Access::AdHoc> object.

=head2 clean_checksums

 cpan-adhoc> clean_checksums
 cpan-adhoc> clean_checksums 1

If no argument is specified, this command displays the current
C<clean_checksums> setting.

If an argument is specified, this command changes the C<clean_checksums>
setting. Cached values will be purged.

The C<clean_checksums> setting determines whether F<CHECKSUMS> data that
relates to non-existent files will be removed. This may be useful if
running against a Mini-CPAN, but requires an access attempt to every
file referenced bu the C<CHECKSUMS> file.

=head2 copy

 cpan-adhoc> copy lib/Foo/Bar.pm

This command copies the named file to the clipboard. The heavy lifting
on this is delegated to the L<Clipboard|Clipboard> module, which is
loaded on the fly. If this module is not installed, an exception is
thrown.

=head2 corpus

 cpan-adhoc> corpus BACH

This command lists all distributions in the index for the given CPAN ID.
More than one CPAN ID can be specified. The CPAN ID is converted to
upper case before use, so the example could equally well be written

 cpan-adhoc> corpus bach

For each CPAN ID, the CPAN ID and electronic mail address are displayed,
followed by the distribution name and date in ISO-8651 format.

If no CPAN ID is provided, the default is the PAUSE ID if that can be
determined; otherwise an exception is thrown.

Supported options are:

=over

=item -before date-and-optional-time

This option, if present, specifies that only distributions created
before the given date be listed.

If the date looks like an ISO-8661 date (that is, three to six groups of
digits each separated by a single non-digit) L<Time::Local|Time::Local>
will be loaded and used to interpret the time.

If the date does not look like an ISO-8661 date,
L<Date::Manip|Date::Manip> will be loaded if possible and used to
interpret the time. If L<Date::Manip|Date::Manip> can not be loaded an
exception will be thrown.

=item -by-date

This Boolean option is a synonym for L<-date|/-date>.

=item -date

If this Boolean option is true, distributions are sorted by date. If
not, they are sorted by distribution name.

=item -development

If asserted, development packages are listed; if not asserted they are
not. Development packages are defined as those with an underscore in
their version number, and digits other than zero before the underscore.
If none of C<-development>, C<-production> or C<-unreleased> is
asserted, all are asserted by default.

=item -distribution

If asserted, only the distribution name is listed, and the author name
is suppressed if only one author was specified.

=item -distro

This is a synonym for L<-distribution|/-distribution>.

=item -format strftime_format

This option specifies the C<strftime()> format for date output. It has
no effect unless C<-date> is specified. The default C<'%Y-%m-%d'>, which
is the format used in the F<CHECKSUMS> file.

=item -latest

If asserted, only the highest-numbered version of any distribution is
displayed.

The default is C<-nolatest>.

=item -match

 -match Acme-

If present, the argument is a regular expression pattern, and only
distributions whose base name matches the pattern will be displayed.

=item -production

If asserted, production packages are listed; if not asserted they are
not. Production packages are defined as those with no underscore in
their version number. If none of C<-development>, C<-production> or
C<-unreleased> is asserted, all are asserted by default.

=item -quiet

If asserted, the name and address of the author is suppressed unless
at least one distribution by that author is listed.

=item -requires

 -requires Test::More
 -requires 'Test::More || Test::V2'

This option selects distributions that require the given modules.

Boolean expressions on module names are permitted, and get munged into
Perl fragments to perform the specified test. If the munge produces
invalid Perl the error message is likely to be unhelpful.

B<Caveat:> If you provide a pernicious expression, on your head be the
consequences.

=item -since date-and-optional-time

This option, if present, specifies that only distributions created
on or after the given date be listed.

For how the date is parsed, see C<-before>.

=item -unpublished

This is a synonym for L<-unreleased|/-unreleased>.

=item -unreleased

If asserted, unreleased packages are listed; if not asserted they are
not. Unreleased packages are defined as those with an underscore in
their version number, and only zeroes and dots before the underscore.
If none of C<-development>, C<-production> or C<-unreleased> is
asserted, all are asserted by default.

=item -with

 -with Build.PL

This option specifies a file which must be present in the distribution
for it to be selected for display. It can be specified multiple times,
in which case all specified files must be present.

=item -without

 -without Build.PL

This option specifies a file which must not be present in the
distribution for it to be selected for display. It can be specified
multiple times, in which case none of the specified files may be
present.

=back

=head2 cpan

 cpan-adhoc> cpan
 cpan-adhoc> cpan file:///home/yehudi/Mini-CPAN/
 cpan-adhoc> cpan -default

If no argument is specified, this command displays the CPAN URL being
used.

If an argument is specified, this command sets the CPAN URL being used.

If the CPAN URL was specified as C<-default>, a default value is
computed from the current setting of C<default_cpan_source>, and that
value is both set as the current soure and displayed. If no default can
be computed from the current C<default_cpan_source>, an error is
displayed and the current setting is left unchanged.

=head2 default_cpan_source

 cpan-adhoc> default_cpan_source
 cpan-adhoc> default_cpan_source cpanm,CPAN
 cpan-adhoc> default_cpan_source -default

If no argument is specified, this command displays the sources of
default CPAN URLs being used.

If an argument is specified, this command sets the sources of default
CPAN URLs. The value is a comma-delimited list.

If the argument was specified as C<-default>, the default value is
reinstated.

B<Note> that setting this value does not affect the C<cpan> setting. If
you want to recompute the C<cpan> URL after setting this, you must do

 cpan-adhoc> cpan -default

The default is C<'CPAN::Mini,cpanm,CPAN,CPANPLUS'>.

=head2 diff

 cpan-adhoc> diff libwww-perl README README
 cpan-adhoc> diff README README
 cpan-adhoc> diff README
 cpan-adhoc> diff -less -u README README

This command runs F<diff> on a file from a CPAN archive and a local
file. The arguments are the distribution name, the file in the
distribution, and the local file. The distribution defaults to the
current distribution, and the file in the distribution defaults to the
local file.

The C<-less> option specifies that the output of F<diff> be viewed in
F<less>. Anything else that looks like an option (that is, that has a
leading dash) will be passed to the F<diff> program. Because of the
possibility of conflict with F<diff> options, C<-less> may not be
abbreviated, though it may be specified as C<--less>, or negated
C<-noless>.

The null option (C<-->) ends option processing, and causes anything
after it to be considered an argument. For example, in

 cpan-adhoc> diff README -readme

the trailing C<-readme> is taken as an option for F<diff>. But in

 cpan-adhoc> diff -- README -readme

the trailing C<-readme> is taken as a file name.

=head2 dist

This is a synonym for L<distribution|/distribution>, for convenience.

=head2 distribution

 cpan-adhoc> distribution libwww-perl

This command looks up the given distributions in the module index (sic),
using an unanchored regular expression, and displays any matches.

=head2 distro

This is a synonym for L<distribution|/distribution>, for convenience.

=head2 exit

 cpan-adhoc> exit

This command causes the script to exit. An end-of-file also works.

=head2 extract

 cpan-adhoc> extract libwww-perl
 cpan-adhoc> extract
 cpan-adhoc> extract libwww-perl lwp-directory
 cpan-adhoc> extract '' lwp-directory

This command extracts the files in the given distribution into
subdirectories of the current directory. If no distribution is
specified, the current distribution is extracted.

An optional second argument specifies the directory into which the
distribution should be extracted. If this is specified the directory
must exist. To specify the second argument while defaulting the first,
specify the first argument as an empty string.

=head2 gview

 cpan-adhoc> module LWP::UserAgent
 cpan-adhoc> gview lib/LWP/UserAgent.pm

This command extracts the named file to a temporary file and then spawns
C<gvim -R> on it. The script holds onto the temporary file until the
next C<gview> command is issued or until it exits.

=head2 help

 cpan-adhoc> help

This command displays the documentation for this script.

=head2 info

 cpan-adhoc> info libwww-perl
 cpan-adhoc> info

This command displays the archive name and CPAN ID of the given
distributions. If no distribution is specified, the current distribution
is displayed.

=head2 less

 cpan-adhoc> less libwww-perl lib/LWP/UserAgent.pm
 cpan-adhoc> less libwww-perl LWP::UserAgent
 cpan-adhoc> less lib/LWP/UserAgent.pm
 cpan-adhoc> less LWP::UserAgent

This command feeds the specified file from the specified distribution to
whatever pager was configured when Perl was built. If the file is not
found, it is assumed to be a module name, and an attempt is made to find
that module's file.

The single-argument form attempts to look up the argument in the module
index. If it is found, that module's file is displayed. Otherwise it
displays the given file in the current distribution, if any

=head2 list

 cpan-adhoc> list libwww-perl
 cpan-adhoc> list

This command lists the files in the given distributions. If no
distribution is specified, the current distribution is listed. The
following options are available:

=over

=item -l

Adds size and date to the output;

=item -less

Views the output in Perl's default pager.

=back

=head2 look

 cpan-adhoc> look libwww-perl
 cpan-adhoc> look

This command expands the distribution into a temporary directory, and
runs your shell with its default being that directory. If no
distribution is specified, the current distribution is expanded.

The shell is the contents of environment variable C<SHELL>, or
F</bin/sh> otherwise.

=head2 ls

This command is a synonym for L<list|/list>.

=head2 metadata

This command displays the metadata for the given distributions. If
metadata is not available (i.e. no F<META.json> or F<META.yml> was
found) a warning will be issued.

The metadata is displayed by the L<CPAN::Meta|CPAN::Meta> C<as_string()>
method. You can specify option C<-less> to view the list in Perl's
default pager.

=head2 module

 cpan-adhoc> module LWP::UserAgent

This command looks up the given modules in the module index, and
displays their version and the distribution they are contained in.

=head2 mtime

 cpan-adhoc> mtime libwww-perl lib/LWP/UserAgent.pm
 cpan-adhoc> mtime lib/LWP/UserAgent.pm

This command displays the modification time of the given file. The first
argument is the distribution name, and the second argument is the file
whose time is to be displayed. If only one argument is given it is
presumed to be the name of a file in the current distribution.

Supported options are:

=over

=item -distribution

If this option is asserted, no file name is specified, and the time
displayed is the modification time of the distribution itself, or of the
cuurrent distribution if no distribution name is given.

=item -format strftime_format

This option specifies the C<strftime()> format for date output. The
default is the value of the command-line C<-date-format> option.

=back

=head2 perldoc

 cpan-adhoc> perldoc libwww-perl-6.03 lib/LWP/UserAgent.pm
 cpan-adhoc> perldoc Libwww-perl LWP::UserAgent
 cpan-adhoc> perldoc lib/LWP/UserAgent.pm
 cpan-adhoc> perldoc LWP::UserAgent

This command feeds the specified file from the specified distribution to
perldoc. If the file is not found, it is assumed to be a module name,
and an attempt is made to find that module's file.

The single-argument form attempts to look up the argument in the module
index. If it is found, that module's documentation is displayed.
Otherwise it displays the given file in the current distribution, if
any.

=head2 ppidump

 cpan-adhoc> ppidump libwww-perl lib/LWP/UserAgent.pm
 cpan-adhoc> ppidump libwww-perl LWP::UserAgent
 cpan-adhoc> ppidump lib/LWP/UserAgent.pm
 cpan-adhoc> ppidump LWP::UserAgent

This command displays a PPI dump of the given file from the given
package. The package may be defaulted. Supported options are:

=over

=item -class

If this Boolean option is true, the dump will contain the class name of
each element.

The default is C<-class>, but this can be negated with C<-noclass>.

=item -comments

If this Boolean option is true, comments will appear in the dump.

The default is C<-comments>, but this can be negated with
C<-nocomments>.

=item -content

If this Boolean option is true, the content of each token will appear in
the dump.

The default is C<-content>, but this can be negated with C<-nocontent>.

=item -gview

If this Boolean option is true, the C<gview> command will be used to
display the dump. Otherwise C<less> will be used.

The default is C<-nogview>.

=item -indent

This integer option specifies the indentation of each nesting level in
the dump.

The default is C<-indent 2>.

=item -locations

If this Boolean option is true, the location of each element in the
source will appear in the dump.

The default is C<-nolocations>.

=item -memaddr

If this Boolean option is true, the memory address of each element in
the dump will appear.

The default is C<-nomemaddr>.

=item -whitespace

If this Boolean option is true, whitespace elements will appear in the
dump.

The default is C<-whitespace>, but this can be negated with
C<-nowhitespace>.

=back

=head2 provides

This command lists the modules provided by the distribution. This comes
from the metadata C<'provides'> key provided that is not empty;
otherwise it is constructed from the metadata and the contents of the
distribution. You can specify option C<-less> to view the list in Perl's
default pager.

=head2 pwd

This command displays the current default directory.

=head2 write

 cpan-adhoc> write libwww-perl
 cpan-adhoc> write

This command writes the archive of the given distributions into the
current directory. If no distribution is specified, the current
distribution is written.

=head1 AUTHOR

Thomas R. Wyant, III F<wyant at cpan dot org>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2012-2022 by Thomas R. Wyant, III

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.10.0. For more details, see the full text
of the licenses in the directory LICENSES.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut

# ex: set textwidth=72 :
